#include "interface_structs.glsl"
#include "../lib/lib/random.glsl"
#include "../lib/lib/kernels.glsl"

#if VECN_DIM == 3
#define PARTICLE_TYPE GLSLParticle3D
#else
#define PARTICLE_TYPE GLSLParticle
#endif

#include "particle_interaction.glsl"


struct PushStruct
{
#if VECN_DIM == 3
	vec3 minRange;
	uint pad0;

	vec3 maxRange;
	uint pad1;

	vec3 cursorPos;
	uint pad2;
#else
	vec2 minRange;
	vec2 maxRange;

	vec2 cursorPos;
	uint pad3;
	uint pad4;
#endif
	uvec2 mouseButtons;
	float cursorRadius;
	float cursorStrength;

	float radius;
	float dt;
	float damping;
	float dampingBorder;

	float gravity;
	uint taskSize;
};



layout(push_constant) uniform PC {PushStruct pc;};
layout(binding = LOCAL_BINDING_OFFSET + 0) buffer PARTICLES { PARTICLE_TYPE particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) readonly buffer FORCE { vecN particle_force[];};
layout(binding = LOCAL_BINDING_OFFSET + 2) writeonly buffer PREDICTED_POS { vecN pred_pos[];};
layout(binding = LOCAL_BINDING_OFFSET + 3) writeonly buffer VELOCITY { vecN vel[];};
layout(binding = LOCAL_BINDING_OFFSET + 4) uniform PARAMS { GLSLParticleUpdateParams params;};


void main()
{
	if(gl_GlobalInvocationID.x >= pc.taskSize)
	{
		return;
	}

	uint id = gl_GlobalInvocationID.x;
	PARTICLE_TYPE elem = particles[id];

	// Accumulate forces
	vecN force = particle_force[id];

#if VECN_DIM == 3
	vec3 down = (params.invModelMat * vec4(0.0, -1.0, 0.0, 0.0)).xyz;
	down = normalize(down);
	force += down * pc.gravity;
#else
	force.y += pc.gravity;
#endif




	vecN cursorForce;
#if VECN_DIM == 3
	cursorForce = getCursorForce(pc.cursorPos, elem.pos, pc.cursorRadius);
#else
	vec2 localMouseCoord = (pc.cursorPos-pc.minRange)*(pc.maxRange - pc.minRange);
	cursorForce = getCursorForce(localMouseCoord, elem.pos, pc.cursorRadius);
#endif
	if(pc.mouseButtons.x == 1) force += cursorForce * pc.cursorStrength;
	if(pc.mouseButtons.y == 1) force -= cursorForce * pc.cursorStrength;

	// Apply forces
	float time = pc.dt * 0.001;
	elem.vel += force * time;
	elem.pos += elem.vel * time;

    vecN boundaryVel = vecN(0.0);
#if VECN_DIM == 3
	boundaryVel = (params.modelMat * vec4(elem.pos, 1.0) - params.modelMatLastFrame * vec4(elem.pos, 1.0)).xyz;
	boundaryVel = (params.invModelMat*vec4(boundaryVel,0.0)).xyz;
	boundaryVel*=10.0;
#endif




	// For now: Hardcoded border collision
	resolveBorderCollision(elem, pc.minRange, pc.maxRange, pc.radius, pc.dampingBorder, boundaryVel);
	//resolveBorderCollision(elem, vec3(0.0), vec3(1.0), 0.01, pc.dampingBorder);
	elem.vel *= pow(pc.damping, time*60.0); // Frame rate independent damping

	//  Write back data

	particles[id] = elem;
	vel[id] = elem.vel;

	// Predicted pos next frame
	PARTICLE_TYPE predElem = elem;
	predElem.vel.y += pc.gravity * time;
	predElem.pos += predElem.vel * time;
	pred_pos[id] = predElem.pos;
}
