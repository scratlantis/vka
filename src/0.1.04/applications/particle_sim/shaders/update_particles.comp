#include "interface_structs.glsl"
#include "../lib/lib/random.glsl"
#include "../lib/lib/kernels.glsl"

#if VECN_DIM == 3
#define PARTICLE_TYPE GLSLParticle3D
#else
#define PARTICLE_TYPE GLSLParticle
#endif

#include "particle_interaction.glsl"


struct PushStruct
{
#if VECN_DIM == 3
	vec3 minRange;
	uint pad0;

	vec3 maxRange;
	uint pad1;

	vec3 cursorPos;
	uint pad2;
#else
	vec2 minRange;
	vec2 maxRange;

	vec2 cursorPos;
	uint pad3;
	uint pad4;
#endif
	uvec2 mouseButtons;
	float cursorRadius;
	float cursorStrength;

	float radius;
	float dt;
	float damping;
	float dampingBorder;

	float gravity;
	uint taskSize;
	uint frameInvocationNr;
	float particleGravityCoef;
};



layout(push_constant) uniform PC {PushStruct pc;};
layout(binding = LOCAL_BINDING_OFFSET + 0) buffer PARTICLES { PARTICLE_TYPE particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) readonly buffer FORCE { vecN particle_force[];};
layout(binding = LOCAL_BINDING_OFFSET + 2) writeonly buffer PREDICTED_POS { vecN pred_pos[];};
layout(binding = LOCAL_BINDING_OFFSET + 3) writeonly buffer VELOCITY { vecN vel[];};
layout(binding = LOCAL_BINDING_OFFSET + 4) uniform PARAMS { GLSLParticleUpdateParams params;};


void main()
{
	if(gl_GlobalInvocationID.x >= pc.taskSize)
	{
		return;
	}

	uint id = gl_GlobalInvocationID.x;
	PARTICLE_TYPE elem = particles[id];

	// Accumulate forces
	vecN force = particle_force[id];

#if VECN_DIM == 3
	vec3 down = (params.invModelMat * vec4(0.0, -1.0, 0.0, 0.0)).xyz;
	down = normalize(down);
	if((params.toggleFlags & PARTICLE_EARTH_GRAVITY_BIT) != 0U)
	{
		force += down * pc.gravity;
	}

	if((params.toggleFlags & PARTICLE_GRAVITY_BIT) != 0)
	{
		uint seed = id * 74775u + params.frameIdx * 289363u +pc.frameInvocationNr * 100423u + 13789u;

		for(int i = 0; i < 10; ++i)
		{
			seed = hash(seed);
			uint randomParticle = seed % pc.taskSize;
			vec3 particlePos = particles[randomParticle].pos;

			vec3 dir = particlePos - elem.pos;
			float distSqr = dot(dir, dir);
			dir = normalize(dir);
			if(distSqr > 0.001)
			{				

				//distSqr = 0.1;
				//dir = vec3(1.0,0.0,0.0);
				force += 0.01 * dir * pc.particleGravityCoef / distSqr;
			}
		}
	}


#else
	force.y += pc.gravity;
#endif




	vecN cursorForce;
#if VECN_DIM == 3
	cursorForce = getCursorForce(pc.cursorPos, elem.pos, pc.cursorRadius);


#else
	vec2 localMouseCoord = (pc.cursorPos-pc.minRange)*(pc.maxRange - pc.minRange);
	cursorForce = getCursorForce(localMouseCoord, elem.pos, pc.cursorRadius);
#endif
	if(pc.mouseButtons.x == 1) force += cursorForce * pc.cursorStrength;
	if(pc.mouseButtons.y == 1) force -= cursorForce * pc.cursorStrength;

	// Apply forces
	float time = pc.dt * 0.001;
	elem.vel += force * time;
	elem.pos += elem.vel * time;

    vecN boundaryVel = vecN(0.0);
#if VECN_DIM == 3
	boundaryVel = (params.modelMat * vec4(elem.pos, 1.0) - params.modelMatLastFrame * vec4(elem.pos, 1.0)).xyz;
	boundaryVel = (params.invModelMat*vec4(boundaryVel,0.0)).xyz;
	vecN oldPos = elem.pos;
	vecN oldVel = elem.vel;
	if(pc.frameInvocationNr == 0U)
	{
		elem.pos = (params.invModelMat * params.modelMatLastFrame * vec4(elem.pos, 1.0)).xyz;
		elem.vel = (params.invModelMat * params.modelMatLastFrame * vec4(elem.vel, 0.0)).xyz;
	}
	//elem.pos = (params.modelMat * params.invModelMatLastFrame * vec4(elem.pos, 1.0)).xyz;
	//elem.pos = (params.invModelMatLastFrame * params.modelMat * vec4(elem.pos, 1.0)).xyz;
	//elem.pos = (params.modelMatLastFrame * params.invModelMat * vec4(elem.pos, 1.0)).xyz;
#endif
	//if((elem.stateFlags & PARTICLE_STATE_IN_BOX_BIT) != 0)
	//{
	//	elem.pos = oldPos;
	//	elem.vel = oldVel;
	//	elem.vel -= 0.2*boundaryVel;
	//}




	// For now: Hardcoded border collision
	if((params.toggleFlags & PARTICLE_BOX_BIT) != 0U)
	{

		if((elem.stateFlags & PARTICLE_STATE_IN_BOX_BIT) != 0)
		{
			resolveBorderCollision(elem, pc.minRange, pc.maxRange, pc.radius, pc.dampingBorder, boundaryVel);
		}
		else if(isInBox(elem, pc.minRange, pc.maxRange, pc.radius))
		{
			elem.stateFlags |= PARTICLE_STATE_IN_BOX_BIT;
			resolveBorderCollision(elem, pc.minRange, pc.maxRange, pc.radius, pc.dampingBorder, boundaryVel);
		}
	}
	else
	{
		elem.stateFlags &= ~PARTICLE_STATE_IN_BOX_BIT;
	}

	//resolveBorderCollision(elem, vec3(0.0), vec3(1.0), 0.01, pc.dampingBorder);
	elem.vel *= pow(pc.damping, time*60.0); // Frame rate independent damping

	//  Write back data

	particles[id] = elem;
	vel[id] = elem.vel;

	// Predicted pos next frame
	PARTICLE_TYPE predElem = elem;
	predElem.vel.y += pc.gravity * time;
	predElem.pos += predElem.vel * time;
	pred_pos[id] = predElem.pos;
}
