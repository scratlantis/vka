#include "../../lib/kernels.glsl"
#include "../../lib/misc.glsl"
struct PushStruct
{
	uint taskSize;
	float radius;
	uint structureSize;
	uint structureOffset;
	float densityCoef;
};

layout(push_constant) uniform PC {PushStruct pc;};

layout(binding = LOCAL_BINDING_OFFSET + 0) readonly buffer PARTICLE_DATA { vecN particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) writeonly buffer DENSITY { float particle_densities[];};


void main()
{
	if(gl_GlobalInvocationID.x >= pc.taskSize)
	{
		return;
	}


	AttributeDescriptor attrDesc;
	attrDesc.stride = pc.structureSize;
	attrDesc.offset = pc.structureOffset;
	attrDesc.alignedSize = ALIGNED_SIZE(vecN);

	uint id				= gl_GlobalInvocationID.x;
	uint range			= pc.taskSize;
	uint attrID			= attributeID(id, attrDesc);

	vecN localPos		= particles[attrID];
	//uint localCellKey	= calcCellKey(localPos, pc.radius, range);
	float density = 0.0f;

	ITERATE_START
	
	vecN otherPos = particles[attributeID(pID.id, attrDesc)];
	density += KERNEL_WEIGHT(distance(localPos, otherPos), pc.radius);
	ITERATE_END
	density += KERNEL_WEIGHT(0, pc.radius);

	//float densityB = 0.0f;
	//for(uint i = 0; i<range; i++)
	//{
	//	vecN otherPos = particles[attributeID(i, attrDesc)];
	//	densityB += KERNEL_WEIGHT(distance(localPos, otherPos), pc.radius);
	//}

	//density = abs(density-densityB);

	density *= KERNEL_NORMALIZATION(pc.radius)*pc.densityCoef * 0.0001;

	particle_densities[id] = density;
	//particle_densities[id] = densityB;
}