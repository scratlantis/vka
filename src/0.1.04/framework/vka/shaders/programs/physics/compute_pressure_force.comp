#include "../../lib/kernels.glsl"
#include "../../lib/misc.glsl"
struct PushStruct
{
	float radius;
	uint structureSize;
	uint structureOffset;
	float forceCoef;
	float targetDensity;
};
layout(push_constant) uniform PC {PushStruct pc;};

#ifndef MAX_PARTICLES_PER_CELL
#define MAX_PARTICLES_PER_CELL 32
#endif

layout(binding = LOCAL_BINDING_OFFSET + 0) readonly buffer PARTICLE_DATA { vecN particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) readonly buffer DENSITY { float particle_densities[];};
layout(binding = LOCAL_BINDING_OFFSET + 2) writeonly buffer FORCE { vec2 pressure_forces[];};


float convertDensityToPressure(float density)
{
	float densityError = density - pc.targetDensity;
	float pressure = densityError * pc.forceCoef;
	return pressure;
}

void main()
{
	if(!validInvocation())
	{
		return;
	}
	vecN force = vecN(0.0);


	AttributeDescriptor attrDesc;
	attrDesc.stride = pc.structureSize;
	attrDesc.offset = pc.structureOffset;
	attrDesc.alignedSize = ALIGNED_SIZE(vecN);

	uint id				= invocationID();
	uint range			= invocationCount();
	uint attrID			= attributeID(id, attrDesc);

	vecN localPos		= particles[attrID];
	float localDensity	= particle_densities[id];
	uint localCellKey	= calcCellKey(localPos, pc.radius, range);


	ITERATE_START

	lastCellKey = pID.cellID;
	vecN otherPos = particles[attributeID(pID.id, attrDesc)];
	float otherDensity = particle_densities[pID.id];
	vecN dir = otherPos - localPos;
	float dist = length(dir);
	if(dist == 0.0)
	{
		dir = randomND(localPos) - vecN(0.5);
	}
	dir = normalize(dir);
	float slope = KERNEL_DERIVATIVE(dist, pc.radius);
	float sharedPressure = 0.5*(convertDensityToPressure(localDensity) + convertDensityToPressure(otherDensity));
	force += sharedPressure * dir * slope * 1.0 / otherDensity;

	ITERATE_END

	pressure_forces[id] = force * pc.forceCoef * 0.01;
}

