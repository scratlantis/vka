#include "../../lib/kernels.glsl"
#include "../../lib/misc.glsl"
struct PushStruct
{
	uint taskSize;
	float radius;
	uint structureSize;
	uint structureOffset;
	float forceCoef;
	float targetDensity;
};

layout(push_constant) uniform PC {PushStruct pc;};

layout(binding = LOCAL_BINDING_OFFSET + 0) readonly buffer PARTICLE_DATA { vecN particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) readonly buffer DENSITY { float particle_densities[];};
layout(binding = LOCAL_BINDING_OFFSET + 2) buffer FORCE { vecN pressure_forces[];};


float convertDensityToPressure(float density)
{
	float densityError = density - pc.targetDensity;
	float pressure = densityError * pc.forceCoef;
	return pressure;
}

void main()
{
	if(gl_GlobalInvocationID.x >= pc.taskSize)
	{
		return;
	}


	AttributeDescriptor attrDesc;
	attrDesc.stride = pc.structureSize;
	attrDesc.offset = pc.structureOffset;
	attrDesc.alignedSize = ALIGNED_SIZE(vecN);

	uint id				= gl_GlobalInvocationID.x;

	vecN force = vecN(0.0);


	uint range			= pc.taskSize;
	uint attrID			= attributeID(id, attrDesc);

	vecN localPos		= particles[attrID];
	float localDensity	= particle_densities[id];


	ITERATE_START(localPos, id)
		vecN otherPos = particles[attributeID(otherId, attrDesc)];
		float otherDensity = particle_densities[otherId];
		vecN dir = otherPos - localPos;
		float dist = length(dir);
		if(dist == 0.0)
		{
			dir = randomND(localPos) - vecN(0.5);
		}
		if(dist > pc.radius)
		{
			continue;
		}
		dir = normalize(dir);
		float slope = KERNEL_DERIVATIVE(dist, pc.radius);
		float sharedPressure = 0.5*(convertDensityToPressure(localDensity) + convertDensityToPressure(otherDensity));
		force += sharedPressure * dir * slope * 1.0 / otherDensity;
	ITERATE_END

	pressure_forces[id] += force * pc.forceCoef * 0.01;
	//pressure_forces[id] += force * 1000.0;
}
