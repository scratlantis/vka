#include "../../lib/kernels.glsl"
#include "../../lib/misc.glsl"
struct PushStruct
{
	uint taskSize;
	float radius;
	uint structureSize;
	uint structureOffset;
	float forceCoef;
};

layout(push_constant) uniform PC {PushStruct pc;};

layout(binding = LOCAL_BINDING_OFFSET + 0) readonly buffer PARTICLE_DATA { vecN particles[];};
layout(binding = LOCAL_BINDING_OFFSET + 1) readonly buffer DENSITY { float particle_densities[];};
layout(binding = LOCAL_BINDING_OFFSET + 2) readonly buffer VEL { vecN velocity[];};
layout(binding = LOCAL_BINDING_OFFSET + 3) buffer FORCE { vecN pressure_forces[];};


void main()
{
	if(gl_GlobalInvocationID.x >= pc.taskSize)
	{
		return;
	}


	AttributeDescriptor attrDesc;
	attrDesc.stride = pc.structureSize;
	attrDesc.offset = pc.structureOffset;
	attrDesc.alignedSize = ALIGNED_SIZE(vecN);

	uint id				= gl_GlobalInvocationID.x;

	vecN force = vecN(0.0);


	uint range			= pc.taskSize;
	uint attrID			= attributeID(id, attrDesc);

	vecN localPos		= particles[attrID];
	float localDensity	= particle_densities[id];


	ITERATE_START(localPos, id)
		vecN otherPos = particles[attributeID(otherId, attrDesc)];
		float otherDensity = particle_densities[otherId];
		vecN dir = otherPos - localPos;
		float dist = length(dir);
		if(dist > pc.radius)
		{
			continue;
		}
		float slope = KERNEL_WEIGHT(dist, pc.radius);
		force +=  (velocity[otherId]-velocity[id])*slope;
	ITERATE_END

	force*= KERNEL_NORMALIZATION(pc.radius);

	pressure_forces[id] += force * pc.forceCoef * 0.0001;
}
